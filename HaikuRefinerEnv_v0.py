import random
import nltk
from nltk.corpus import cmudict
import numpy as np
from textblob import Textblob
import syllapy


class HaikuEnvironment:
    def __init__(self):
        self.target_syllables = [5, 7, 5] 
        self.current_line = 0 
        self.current_syllable_count = 0
        self.haiku = ["", "", ""]  
        
    def reset(self):
        self.current_line = 0
        self.current_syllable_count = 0
        self.haiku = ["", "", ""]
        return self.haiku
    
    def step(self, action):
        word = action
        syllables = self.syllable_count(word)
        
        if self.current_syllable_count + syllables <= self.target_syllables[self.current_line]:
            self.haiku[self.current_line] += " " + word
            self.current_syllable_count += syllables
            reward = 1  # Reward for maintaining syllable count
            
            if self.current_syllable_count == self.target_syllables[self.current_line]:
                # Move to next line
                self.current_line += 1
                self.current_syllable_count = 0
                if self.current_line == 3:
                    done = True  # End after 3 lines
                else:
                    done = False
            else:
                done = False
        else:
            reward = -1 
            done = False
        
        reward += self.reward_function(word)
        
        return self.haiku, reward, done
    
    def reward_function(self, word):
        reward = 0
        
        # Syllable Constraint 
        syllables = self.syllable_count(word)
        if syllables == 0:
            reward -= 2 
        
        # Object Constraint 
        valid_objects = self.objects
        if word.lower() not in valid_objects:
            reward -= 1  
            
        # Sentiment Constraint 
        sentiment = TextBlob(word).sentiment.polarity 
        if self.target_sentiment == 'positive' and sentiment < 0:
            reward -= 1  
        elif self.target_sentiment == 'negative' and sentiment > 0:
            reward -= 1 
        
        # Coherence Constraint 
        
        return reward


    def generate_suggestions(self):
        # Create a list of suggestions for each line generated by an LM (This will be the action space) - They need to be coherent and relate to our descriptions
        suggestions = []        
        return
    
    def syllable_count(self, wrd):
        return syllapy.count(wrd)

class QLearningAgent:
    def __init__(self, actions):
        self.actions = actions
        self.q_table = np.zeros(len(actions))  
        self.alpha = 0.1 
        self.gamma = 0.9  
        self.epsilon = 0.1  

    def choose_action(self):
        if random.uniform(0, 1) < self.epsilon:
            return random.choice(self.actions) 
        else:
            return self.actions[np.argmax(self.q_table)]  

    def update_q_value(self, action, reward):
        index = self.actions.index(action)
        self.q_table[index] += self.alpha * (reward + self.gamma * np.max(self.q_table) - self.q_table[index])


